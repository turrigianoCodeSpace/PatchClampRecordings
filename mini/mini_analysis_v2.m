%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%% MINI ANALYSIS 2.0 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% What you will need to run this script:

% 1) Organize data files.  Data obtained on each day should be saved in a folder
% named by the date of the experiment (6-digit format, e.g. 220810).
% Files that belong to a specific cell should have the same prefix "cellx' 
% where x indicates the cell number of the day.

% 2) Organize analyzed files. All parameters generated by this analysis
% will be saved in a mat file named "MINIANALYSIS_xxxxxx". Have a separate
% foler for these. Parameters related to passive properties will also be
% saved in a separate mat file, also set up a folder for them.

% 3) The script automatically generate a cell_id cell array which serves as
% a file management system. Each file should be named as such:
% cellx_xxxx-xxxx (if you prefer automatic sweeps) or cellx_xxxx (if you prefer manual sweeps). 
% The cell_id array stores the experiment number, the cell
% number, and the trace number. For example, cell_id{1,1}
% indicates experiment 1, under which you will find several cell number arrays
% representing each cell (cell_id{1,1}{1,1} indicates the first cell in
% experiment 1). Within each cell number array, the id # of all traces that belongs to
% this cell is stored in a column.

% 4) Excise X data for template matching.  Run the included script excise_x_points* to manually
% remove seal tests, noisy regions, and noisy traces.  This only needs to
% be done once.

%% Experiment names and folder pathes

%Name of the data folder
experiment = {'230729'};

%Name of the subfolder (if applicable)
sub = '';

%location of the excised file
excised_data_fp = '/Users/wwneuro/My_Drive/Lab/Data/culture_experiments/excised_data/';

%Filepath where you keep data folders
fp_data = '/Users/wwneuro/My_Drive/Lab/Data/culture_experiments/mini/';

%location to save the analyzed mini data
fp_analyzed_data = ...,
    '/Users/wwneuro/My_Drive/Lab/Data_analysis/culture_experiments/analyzed_mini_results/';

%location to save the analyzed passive property data
fp_pp = ...,
    '/Users/wwneuro/My_Drive/Lab/Data_analysis/culture_experiments/analyzed_seal_test/';

%% save and plotting settings

%Current orientation; 1 = downward, 2 = upward
%(upward currents will be flipped during analysis)
cur_type = 1;

%whether to save results
save_results = 1;

%whether to show figures for each mini trace; 0 = no, 1 = yes.
figures_on_mini = 0;

%whether to show figures for passive property analysis; 0 = no, 1 = yes.
figures_on_pp = 0;

%whether to display frequency for each trace;  0 = no, 1 = yes.
display_frq = 1;

troubleshoot_events_detect = 0;
%%%%%% opens a figure window that shows individual events that have been
%%%%%% selected/analyzed and displays relevant event properties

troubleshoot_events_wavg = 0;
%%%%%% opens a figure window that shows individual events selected for wavg
%%%%%% analysis and decay fitting

%%%%%%%%%%%%%%%%%%%%%%%%% SEAL TEST PARAMETERS %%%%%%%%%%%%%%%%%%%%%%%%%%%%

%voltage step onset
step_start = 0.5; %in s

%voltage step amplitude
vstep = -0.005; %in V

%voltage step duration
pulse = 0.5;

%cell stats column number
cell_stats_col = 7;

%sampling rate (acquisition sampling rate)
samprate = 10000;

%PP CV cutoff
pp_cv_cutoff = 15;

%%%%%%%%%%%%%%%%%%%%%%%%% TEMPLATE PARAMETERS %%%%%%%%%%%%%%%%%%%%%%%%%%%%

samplert = 5000;
%%%%%% Sampling rate at which to analyze data (not the acquisition
%%%%%% sampling rate from wavesurfer!)

tRISE = 0.0005*samplert;

tDECAY = 0.0025*samplert;

num_zeros_temp_BL = 10;

num_pts_temp = 18;
%%%%%% Number of points in template

detect_crit_thresh = 0.10;
%%%%%% Threshold value for 'acceptable' template match w/ data

%%%%%%%%%%%%%%%%%%%%%%%%%% EXCLUSION CRITERIA %%%%%%%%%%%%%%%%%%%%%%%%%%%%

amp_cutoff_low = 10;
amp_cutoff_high = 250;
%%%%%% (pA) Value range of acceptable events amplitudes

refractory_per = 15;%15;
%%%%%% minumum number of points between events (REFRACTORY PERIOD)

numptsBL = 15;
%%%%%% number of points before event start to use for determining whether
%%%%%% event has a stable baseline

BL_slope_thresh_hi = 0.8;
BL_slope_thresh_lo = -0.8;
%%%%%% Slope of baseline period before individual events must be between bounds

decay_frac_thresh = 0.9;
%%%%%% end of decay is defined as point at which smoothed data returns to
%%%%%% this fraction of baseline amplitude

event_charge_thresh = 1e-2;
%%%%%% individual events must have charge (area under curve) greater than
%%%%%% this value to be accepted

fit_noise_thresh = 3.0;%1.9;
%%%%%% If max value of eventBL >= fit_noise_thresh * std(data), exclude event
%%%%%% prevents fitting too many noise transients

num_pts_decay_fit = 30;%35;
%%%%%% number of points for exponential fit to decay

min_decay_rsquare = 0.25;
%%%%%% Minimum R-squared value acceptable for exponential fit to event
%%%%%% decay 

min_rsquare_wavg = 0.1;%0.75;
%%%%%% Minimum rsquare value for exponential fit to decay of events
%%%%%% (applies to waveform averages only)

max_decay_rmse = 3;%2.5;
%%%%%% Maximum RMSE value acceptable for exponential fit to event
%%%%%% decay (exclude if higher)

if cur_type == 1
    risetime_cutoff = 2;
    BLBAD_thresh = 5.0;
    S_E_L = 180;
elseif cur_type == 2
    risetime_cutoff = 5;
    BLBAD_thresh = 5.0;
    S_E_L = 210;
end
%%%%%% risetime_cutoff, in ms: Detected events must have SHORTER OR EQUAL rise time than this value 
%%%%%% (in order to be accepted)
%%%%%% BLBAD_thresh: If event start value is more than this much over baseline, exclude event
%%%%%% S_E_L: Standard event length, MUST BE DIVISIBLE BY 3


%% mini event template generation

% -------------------------------------
% TEMPLATE
% NORM is the normalization factor
clear template

NORM            = 0.02;
spoints         = 1: (samplert * 0.020);
template        = zeros(1,samplert * 0.020);

tcount = 0;

for t = 0:length(spoints)
    tcount = tcount+1;
    template(tcount)     = NORM *(1 - exp(-t/tRISE)) * exp(-t/tDECAY); %create a normalized template of an event
end

template = [zeros(1,num_zeros_temp_BL) template]; %%% this forces a stable baseline prior to each mini
template = template(1,1:num_pts_temp);

[~,pk_ind] = max(template);   %%%peak index of template

temp_time = (0:0.2:50);%time points also normalized
temp_time = temp_time(1,1:length(template));
%             figure
%             plot(temp_time,template)
%             axis([0 5 0 max(template)])
n = length(template);
% END TEMPLATE
% -------------------------------------

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% HIPASS FILTER DESIGN %%%%%%%%%%%%%%%%%%%%%%%
%%%%%%% Excised Data is run through a high pass filter to remove slow
%%%%%%% deviations from baseline

hfilt = designfilt('highpassiir', ...       % Response type
    'StopbandFrequency',0.35, ...     % Frequency constraints
    'PassbandFrequency',0.75, ...
    'PassbandRipple',0.5, ...
    'StopbandAttenuation',3, ...    % Magnitude constraints
    'SampleRate',5000);

%% Data readout

numexp = numel(experiment); 

%Pre-allocation
AMP_ALL = cell(1,numexp);
FRQ = cell(1,numexp);
WAVG = cell(1,numexp);
TOTAL_TIME = cell(1,numexp);
RISE = cell(1,numexp);
DECAY = cell(1,numexp);
wavgs_raw = cell(1,numexp);
TIME_INDICES = cell(1,numexp);
EVENT_CHARGE = cell(1,numexp);

aDAT_all = cell(1,numexp);
EVENT_START_INDICES = cell(1,numexp);
PT3_AVERAGES = cell(1,numexp);
SMOOTH_PEAK_INDICES = cell(1,numexp);
DECAY_INDICES = cell(1,numexp);
PT3_DECAY_VALUES = cell(1,numexp);

meanAmp = cell(1,numexp);
mini_count = cell(1,numexp);
total_time = cell(1,numexp);

Rs_est = cell(1,numexp);
Rs = cell(1,numexp);
Rin = cell(1,numexp);
Cm = cell(1,numexp);
Cm_est = cell(1,numexp);
Vm = cell(1,numexp);
cell_stats = cell(1,numexp);


for jj = 1:1%numel(experiment)
    %Name of the analyzed mini results
    save_mini_file_name = strcat('MINIANALYSIS_',experiment{jj},sub,'.mat');

    %Name of the analyzed passive property results
    save_pp_file_name = strcat('pp_',experiment{jj},sub,'.mat');

    %this needs to be copied from excise_x_points
    excised_filename = strcat('excised_',experiment{jj},sub,'.mat');
    
    %import excised coordinates
    cd(excised_data_fp)
    excised_data = load(excised_filename);
    excised_points = excised_data.excised_points;
    
    current_experiment = experiment{jj};
    current_folder = strcat(fp_data,current_experiment,'/',sub);
    
    
    [raw_h5_files,data,cell_id,cell_num,filename] = h5_file_readout(current_folder);

    
    %Pre-allocate cell stats parameters
    Rin_stats = NaN(max(cell_num),cell_stats_col);
    Cm_stats = NaN(max(cell_num),cell_stats_col);
    Vm_stats = NaN(max(cell_num),cell_stats_col);
    Rs_stats = NaN(max(cell_num),cell_stats_col);
    Rin_outliers = cell(1,max(cell_num));
    Cm_outliers = cell(1,max(cell_num));
    Vm_outliers = cell(1,max(cell_num));
    Rs_outliers = cell(1,max(cell_num));
    amp_stats = NaN(max(cell_num),2);
    ave_frq = NaN(max(cell_num),1);
    
    
    
    %% prepare data for analysis
    
    for ci = 1:max(cell_num)
        if isempty(cell_id{1,ci})
            continue
        else
            trace_start = cell_id{1,ci}(1,1);
            trace_end = cell_id{1,ci}(end,1);
            
            for ti = trace_start:trace_end
                    if ~ismember(ti,cell_id{1,ci})

                       disp(strcat('Trace',num2str(ti), ' does not exist!'))

                       FRQ{1,jj}{1,ci}(ti,1) = NaN;
                       AMP_ALL{1,jj}{1,ci}(:,ti) = NaN;
                       meanAmp{1,jj}{1,ci}(ti,1) = NaN;
                       mini_count{1,jj}{1,ci}(ti,1) = NaN;

                       TOTAL_TIME{1,jj}{1,ci}(ti,1) = NaN;
                       RISE{1,jj}{1,ci}(:,ti) = NaN;
                       DECAY{1,jj}{1,ci}(:,ti) = NaN;
                       wavgs_raw{1,jj}{1,ci}{ti} = NaN;
                       TIME_INDICES{1,jj}{1,ci}(:,ti) = NaN;
                       EVENT_CHARGE{1,jj}{1,ci}(:,ti) = NaN;
                       aDAT_all{1,jj}{1,ci}(:,ti) = NaN;
                       
                       Rs_est{1,jj}{1,ci}(ti,1) = NaN;
                       Rs{1,jj}{1,ci}(ti,1) = NaN;
                       Rin{1,jj}{1,ci}(ti,1) = NaN;
                       Cm{1,jj}{1,ci}(ti,1) = NaN;
                       Cm_est{1,jj}{1,ci}(ti,1) = NaN;
                       Vm{1,jj}{1,ci}(ti,1) = NaN;

                       continue

                    else
                        
                        %calculate passive properties before resampling
                        vals = data{1,ci}(:,ti);
                        
                        [Rs_est_temp, Rs_temp, Rin_temp, Cm_temp, Cm_est_temp, Vm_temp] = ...
                            get_passive_properties(vals, step_start, pulse, vstep, samprate, figures_on_pp);
                        
                        Rs_est{1,jj}{1,ci}(ti,1) = Rs_est_temp;
                        Rs{1,jj}{1,ci}(ti,1) = Rs_temp;
                        Rin{1,jj}{1,ci}(ti,1) = Rin_temp;
                        Cm{1,jj}{1,ci}(ti,1) = Cm_temp;
                        Cm_est{1,jj}{1,ci}(ti,1) = Cm_est_temp;
                        Vm{1,jj}{1,ci}(ti,1) = Vm_temp;
                        
                        %check these
                        clear resampled
                        clear yy
                        clear aDAT
                        clear timeindx
                        clear n_ind

                        %resample @1:2
                        resampled(1:numel(resample(vals,1,2)),1) = resample(vals,1,2);

                        % get coordinates from the excised data file
                        yy = [];
                        start_end = excised_points{1,jj}{1,ci}{ti}; 
                        start_end = start_end(~isnan(start_end));
                        start_end = start_end(start_end>0);

                        if mod(numel(start_end),2) == 0
                            for m = 1:2:numel(start_end)
                                if start_end(m+1) > numel(resampled)
                                    start_end(m+1) = numel(resampled);
                                end
                                warning('off','all')

                                %FILTER DATA (high-pass)
                                yy(numel(yy)+1:numel(yy)+numel(resampled(start_end(m):start_end(m+1)))) = ...
                                    filter(hfilt,detrend(resampled(start_end(m):start_end(m+1))));
                                warning('on','all')
                            end

                        else
                            disp(strcat('Warning...','Cell',num2str(ci),' Trace',num2str(ti),...
                                ' does not contain an appropriate number of excision points'))
                            yy = filter(hfilt,detrend(resampled));

                        end

                        yy = yy(isfinite(yy));
                        
                        if cur_type == 1
                            aDAT(1:numel(yy),1) = yy;
                        elseif cur_type == 2
                            aDAT(1:numel(yy),1) = -yy;
                        end

                        %template matching
                        clear SCALE OFFSET SSE STANDARDERROR DETECT_CRIT DETECT_CRIT2
                        SCALE = NaN(1,numel(aDAT));
                        OFFSET = NaN(1,numel(aDAT));
                        SSE = NaN(1,numel(aDAT));
                        STANDARDERROR = NaN(1,numel(aDAT));
                        DETECT_CRIT = NaN(1,numel(aDAT));

                        for ii = 1:length(aDAT) - n % difference between data and template

                            dat                 = aDAT(ii:ii+n-1); % resampled and filtered
                            sTop                = sum(template*dat) - sum(template)*sum(dat)/n;
                            sBottom             = sum(template.^2) - sum(template) * sum(template)/n;
                            SCALE(ii)           = sTop/sBottom;

                            OFFSET(ii)          = (sum(dat) - SCALE(ii)*sum(template))/n;

                            if SCALE(ii) > 0
                                fitted_template = zeros(1,numel(template));
                            else
                                fitted_template     = template*SCALE(ii) + OFFSET(ii);
                            end
                            %
                            %                 plot(dat), hold on
                            %                 plot(fitted_template,'r'), hold off
                            %                 if min(fitted_template) < -5e-12
                            %                     pause
                            %                 end
                            %                 drawnow

                            %                 if max(fitted_template) - min(fitted_template) > 5e-12
                            % %                     figure
                            %                     plot(dat)
                            %                     hold on
                            %                     plot(fitted_template,'r')
                            %                     hold off
                            %                     pause
                            % %                     close
                            %                 end

                            %for template matching, amplitude cutoffs are 5 and 200.

                            if abs(fitted_template(1,1)-fitted_template(1,pk_ind)) > 5 ...,
                                    && abs(fitted_template(1,1)-fitted_template(1,pk_ind)) < 200
                                SSE(ii)             = sum(dat)^2 + SCALE(ii)^2 * sum(template.^2) ...,
                                    + n*OFFSET(ii)^2 - 2*(SCALE(ii) * sum(template*dat)) + ...,
                                    OFFSET(ii) * sum(dat) - SCALE(ii) * OFFSET(ii) * sum(template);

                                STANDARDERROR(ii)   = (SSE(ii)/(n-1))^(1/2);
                                DETECT_CRIT(ii)     = SCALE(ii)/STANDARDERROR(ii);
                            else
                                SSE(ii)             = sum(dat)^2 + SCALE(ii)^2 * sum(template.^2) + ...,
                                    n*OFFSET(ii)^2 - 2*(SCALE(ii) * sum(template*dat)) + ...,
                                    OFFSET(ii) * sum(dat) - SCALE(ii) * OFFSET(ii) * sum(template);

                                STANDARDERROR(ii)   = (SSE(ii)/(n-1))^(1/2);
                                DETECT_CRIT(ii)     = 0;
                            end
                        end

                        DETECT_CRIT2 = DETECT_CRIT;
                        DETECT_CRIT2(DETECT_CRIT2>0) = 0;
                        DETECT_CRIT2 = DETECT_CRIT2/min(DETECT_CRIT2);

                        thresh          = detect_crit_thresh;  %threhold for detection
                        past            = DETECT_CRIT2>thresh;
                        hits            = 0.*DETECT_CRIT2;
                        hits(past)      = 1;
                        hits            = [ 0 diff(hits) ];
                        hits_temp = hits;
                        hits(hits<0)    = 0;    % finds all points where there is a crossing

                        timeindx        = find(hits);  % the sample numbers within the chunk where there are events

                        %remove NaNs in timestamps 
                        n_ind = find(~isnan(aDAT));
                        timeindx = timeindx(ismember(timeindx,n_ind));


                        % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                        %%%%%%%%%%%%%%%%%%%%% PEAK/START DETECTION %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

                        disp('Detecting events...')

                        timeindx(timeindx >= max(timeindx)-200) = NaN;
                        timeindx = timeindx(~isnan(timeindx));
                        timeindx_slopeBL = NaN(1,numel(timeindx));
                        timeindx_rise = NaN(1,numel(timeindx));
                        timeindx_decay = NaN(1,numel(timeindx));
                        timeindx_decayfit = NaN(1,numel(timeindx));
                        timeindx_charge = NaN(1,numel(timeindx));
                        timeindx_BLBAD = NaN(1,numel(timeindx));
                        timeindx_noiseSTD = NaN(1,numel(timeindx));
                        timeindx_multipk = NaN(1,numel(timeindx));
                        timeindx_otherA = NaN(1,numel(timeindx));
                        timeindx_otherB = NaN(1,numel(timeindx));
                        timeindx_otherC = NaN(1,numel(timeindx));
                        timeindx_otherD = NaN(1,numel(timeindx));
                        timeindx_refractory_per = NaN(1,numel(timeindx));
                        timeindx_decay_start = NaN(1,numel(timeindx));
                        timeindx_BLnopts = NaN(1,numel(timeindx));
                        timeindx_no_decay = NaN(1,numel(timeindx));

                        std_BL = NaN(1,numel(timeindx));
                        mean_slope_BL = NaN(1,numel(timeindx));
                        pt3_BL = NaN((S_E_L/3),numel(timeindx));

                        event = NaN(S_E_L+1,numel(timeindx));
                        norm_event = NaN(S_E_L+1,numel(timeindx));
                        pt3_avg = NaN((S_E_L/3)+1,numel(timeindx));
                        slope = NaN(S_E_L/3,numel(timeindx));
                        slope3_avg = NaN((S_E_L/3)-2,numel(timeindx));
                        sm_pk_val = NaN(1,numel(timeindx));
                        sm_pk_ind = NaN(1,numel(timeindx));
                        slope_pk_val = NaN(1,numel(timeindx));
                        slope_pk_ind = NaN(1,numel(timeindx));
                        event_start_ind = cell(1,numel(timeindx));
                        pt3_decay = NaN(S_E_L*(2/3),numel(timeindx));
                        decay_ind = NaN(1,numel(timeindx));
                        TOTAL_RISE_TIME = NaN(1,numel(timeindx));
                        RISE_TIME = NaN(1,numel(timeindx));
                        DECAY_TIME = NaN(1,numel(timeindx));
                        RAW_AMP = NaN(1,numel(timeindx));
                        EVENT_CHARGE_CURR = NaN(1,numel(timeindx));
                        

                        aaDAT = aDAT;

                        %%%Fitting function of the decay phase
                        s = fitoptions('Method','NonlinearLeastSquares','Startpoint',[-11 -0.4],...
                                    'Lower',[-400,-3],'Upper',[-5,-0.04]);
                                    f = fittype('a*exp(b*x)','options',s);

                        for i = 1:numel(timeindx)
                            if timeindx(i)+S_E_L > numel(aDAT)
                                event(:,i) = aDAT((numel(aDAT)-size(event,1)+1):numel(aDAT));
                            else
                                event(:,i) = aDAT(timeindx(i):timeindx(i)+S_E_L);
                            end

                            for k = 4:((S_E_L/3)+1)
                                pt3_avg(k-2,i) = (event(k-2,i)+event(k-3,i)+event(k-1,i))/3;
                                %average amplitudes of every 3 points
                            end
                            pt3_avg(1,i) = (event(1,i)+event(2,i))/2;%first two points
                            pt3_avg(S_E_L/3,i) = (event(S_E_L+1,i)+event(S_E_L,i)+event(S_E_L-1,i))/3;
                            pt3_avg(S_E_L/3+1,i) = (event(S_E_L+1,i)+event(S_E_L,i))/2;
                            for k = 1:S_E_L/3
                                slope(k,i) = pt3_avg(k,i) - pt3_avg(k+1,i); %slope of every 6 points
                            end
                            for k = 4:((S_E_L/3)+1)
                                slope3_avg(k-2,i) = (slope(k-2,i)+slope(k-3,i)+slope(k-1,i))/3;  %averaging slopes
                            end
                            slope3_avg(1,i) = (slope(1,i)+slope(2,i))/2;
                            slope3_avg((S_E_L/3)-1,i) = (slope((S_E_L/3)-1,i)+slope(S_E_L/3,i))/2;

                            %%%find the peak amplitude (value and location)
                            [sm_pk_val(i),sm_pk_ind(i)] = min(pt3_avg(:,i));
                            %raw_sm_pk_val(i) = sm_pk_val(i);
                            %raw_sm_pk_ind(i) = sm_pk_ind(i);


                            %%%%%%%%%%%%%%%%%%% ELIMINATING FALSE-POSITIVES %%%%%%%%%%%%%%%%%%%%%%%%%%%

                            %locate event starting point
                            if sm_pk_val(i) ~= pt3_avg(end,i)
                                [slope_pk_val(i),slope_pk_ind(i)] = max(slope3_avg(:,i)); % the largest average slope
                                event_start_ind{i} = find(slope3_avg(1:slope_pk_ind(i),i) <= 0.3* slope_pk_val(i),1,'last');
                                %%%%%  Start is defined as the time before midrise when
                                %%%%%  slope of 3pt smooth is <= 0.3* midrise slope

                                if isempty(event_start_ind{i}) == 1
                                    event_start_ind{i} = 1;
                                end

                                if event_start_ind{i} > sm_pk_ind(i)
                                    sm_pk_val(i) = NaN;
                                    sm_pk_ind(i) = NaN;
                                    timeindx_otherB(i) = timeindx(i); %start found after peak
                                    continue
                                end

                                %%%%% will cause error during WAVG if this value is
                                %%%%% zero or less                            
        %                         if (num_zeros_temp_BL*4)-sm_pk_ind(i) <= 0
        %                             sm_pk_val(i) = NaN;
        %                             sm_pk_ind(i) = NaN;
        %                             timeindx_otherC(i) = timeindx(i); 
        %                         end

                                % will cause error if event starts later than
                                % this point
                                if isempty(event_start_ind{i})==0
                                    if event_start_ind{i} >= numptsBL+12 
                                        sm_pk_val(i) = NaN;
                                        sm_pk_ind(i) = NaN;
                                        timeindx_otherD(i) = timeindx(i); 
                                    end
                                end

                                %remove multipeak events
                                if max(slope3_avg(:,i)) <= 1.5*max(slope3_avg(1:event_start_ind{i}-1,i))
                                    sm_pk_val(i) = NaN;
                                    sm_pk_ind(i) = NaN;
                                    timeindx_multipk(i) = timeindx(i);
                                    continue
                                end
                            else
                                %will cause errot if peak is the last point in
                                %the average 3 points vector
                                sm_pk_val(i) = NaN;
                                sm_pk_ind(i) = NaN;
                                timeindx_otherA(i) = timeindx(i);
                                continue
                            end

                            %the location of the event start point in raw data
                            event_start_aDAT_ind = timeindx(i)+event_start_ind{i}-1;

                            %baseline assessment
                            if (event_start_aDAT_ind-numptsBL+1) > 0
                                BL_vals = aDAT(event_start_aDAT_ind-numptsBL+1:event_start_aDAT_ind);
                            else
                                sm_pk_val(i) = NaN;
                                sm_pk_ind(i) = NaN;
                                timeindx_BLnopts(i) = timeindx(i); %not enough points for baseline
                            end

                            %exclude events without a smooth baseline
                            if max(BL_vals-mean(BL_vals(1:numptsBL-3),'omitnan'))...,
                                    >= fit_noise_thresh*std(aDAT)+mean(aDAT)
                                            sm_pk_val(i) = NaN;
                                            sm_pk_ind(i) = NaN;
                                            timeindx_noiseSTD(i) = timeindx(i);
                                continue              
                            end

                            %exclude events whose starting points deviate
                            %too much from the baseline (could be detected as
                            %false-positive events)
                            if ~isnan(sm_pk_ind(i))
                                try
                                    for k = 2:((S_E_L/3)+1)
                                        pt3_BL(k-1,i) = (aDAT(event_start_aDAT_ind-((S_E_L/3)+2)+k)... 
                                            +aDAT(event_start_aDAT_ind-((S_E_L/3)+1)+k)...,
                                            +aDAT(event_start_aDAT_ind-((S_E_L/3)+3)+k))/3;
                                    end
                                catch
                                end

                                if pt3_avg(event_start_ind{i},i) - mean(BL_vals,'omitnan') >= BLBAD_thresh
                                    %disp(pt3_avg(event_start_ind{i},i)-mean(BL_vals,'omitnan'));
                                    sm_pk_val(i) = NaN;
                                    sm_pk_ind(i) = NaN;
                                    timeindx_BLBAD(i) = timeindx(i);
                                    continue
                                end

                                %baseline slope should be within bounds
                                BL_fit = fitlm((1:numptsBL)',BL_vals);
                                intercept = BL_fit.Coefficients{1,1};
                                slope_fit = BL_fit.Coefficients{2,1};
                                x_coords_fit = ([1 numptsBL]);
                                y_coords_fit = ([slope_fit+intercept slope_fit*numptsBL+intercept]);
                                if troubleshoot_events_detect == 1
                                    plot(x_coords_fit,y_coords_fit,'r-');
                                end

                                rsquared = BL_fit.Rsquared.Ordinary;
                                mean_slope_BL(i) = slope_fit;

                                if mean_slope_BL(i) < BL_slope_thresh_hi && mean_slope_BL(i) > BL_slope_thresh_lo
                                    if troubleshoot_events_detect == 1
                                        shg
                                        plot(x_coords_fit,y_coords_fit-mean(BL_vals,'omitnan'),'r-');
                                        disp(strcat('event',num2str(i)))
                                        disp(strcat('mean slope BL =',num2str(mean_slope_BL(i))))
                                        disp(strcat('rsquared =',num2str(rsquared)))
                                    end
                                else
                                                                                         
                                    sm_pk_val(i) = NaN;
                                    sm_pk_ind(i) = NaN;
                                    timeindx_slopeBL(i) = timeindx(i); %slope baseline out of bounds
                                    continue
                                end
                                std_BL(i) = std(pt3_BL(11:30,i));
                            end

                            %Rise time measurement
                            if ~isnan(sm_pk_ind(i))
                                %locate peak
                                amplitude = -1*(pt3_avg(sm_pk_ind(i),i) - mean(BL_vals,'omitnan'));
                                peak_i = sm_pk_ind(i)-event_start_ind{i}+numptsBL;

                                %normalize event
                                event_wBL = aDAT(event_start_aDAT_ind-numptsBL+1:event_start_aDAT_ind+S_E_L+1-numptsBL);
                                norm_event(:,i) = event_wBL - mean(event_wBL(1:numptsBL),'omitnan');

                                %rise upper bound- 10%
                                rise_start_10pc_i = find(norm_event(11:peak_i,i) <= -0.1*amplitude,1,'first');
                                %rise lower bound- 90%
                                rise_end_90pc_i = find(norm_event(11:peak_i,i) >= -0.9*amplitude,1,'last');

                                %exclude events without proper rise times
                                if isempty(rise_start_10pc_i)||isempty(rise_end_90pc_i) == 1
                                    sm_pk_val(i) = NaN;
                                    sm_pk_ind(i) = NaN;
                                    timeindx_rise(i) = timeindx(i);
                                    RISE_TIME(i) = NaN;
                                else

                                    %calculating rise time (in ms)
                                    rise_vals_10to90 = norm_event(rise_start_10pc_i:rise_end_90pc_i,i);

                                    %0-100% rise
                                    TOTAL_RISE_TIME(i) = (sm_pk_ind(i)-event_start_ind{i})/(samplert);
                                    %10-90% rise
                                    RISE_TIME(i) = (rise_end_90pc_i-rise_start_10pc_i)/(samplert);

                                    if troubleshoot_events_detect == 1
                                        disp(strcat('RISE = ',num2str(RISE_TIME(i))))
                                    end

                                    %exclude events with high rise times
                                    if RISE_TIME(i) > (risetime_cutoff/1000)
                                        sm_pk_val(i) = NaN;
                                        sm_pk_ind(i) = NaN;
                                        timeindx_rise(i) = timeindx(i);
                                        RISE_TIME(i) = NaN;
                                        continue
                                    end
                                end
                            end


                            %decay time measurement
                            if ~isnan(sm_pk_ind(i))
                                decay_amp = NaN(1,(S_E_L*(2/3)));
                                for k = 2:(S_E_L*(2/3)+1)
                                    pt3_decay(k-1,i) = (event(k-1+sm_pk_ind(i),i)+...,
                                        event(k+sm_pk_ind(i),i)+event(k+1+sm_pk_ind(i),i))/3;
                                    decay_amp(k-1) = mean(BL_vals,'omitnan') - pt3_decay(k-1,i);
                                end

                                %decay starting point- 90% of peak amp
                                decay_start_i = find(norm_event(peak_i:peak_i+20,i) >= -0.9*amplitude,1,'first')-1+peak_i;

                                %exclude event if no decay starting point found
                                if isempty(decay_start_i) == 1
                                    sm_pk_val(i) = NaN;
                                    sm_pk_ind(i) = NaN;
                                    timeindx_decay_start(i) = timeindx(i);
                                    continue
                                end

                                %define decay region
                                decay_i = find(decay_amp <= (1-decay_frac_thresh)*(-1*(pt3_avg(sm_pk_ind(i),i)...,
                                    - mean(BL_vals,'omitnan'))),1,'first');
                                decay_vals_forfit = norm_event(decay_start_i:decay_start_i+num_pts_decay_fit,i);
                                decay_i_wBL = sm_pk_ind(i)-event_start_ind{i}+numptsBL+2+decay_i;

                                % if decay fitting region cannot be found
                                if i+1 > numel(timeindx)
                                    continue
                                else
                                    if isempty(decay_i) ==1 || (decay_i+timeindx(i)+sm_pk_ind(i))>timeindx(i+1)
                                        decay_i = NaN;
                                        DECAY_TIME(i) = NaN;
                                        sm_pk_val(i) = NaN;
                                        sm_pk_ind(i) = NaN;
                                        timeindx_no_decay(i) = timeindx(i);
                                    else
                                        DECAY_TIME(i) = (decay_i+2)/samplert;
                                    end
                                end

                                %rise time must be shorter than decay,
                                %otherwise exclude
                                if ~isnan(DECAY_TIME(i)) && TOTAL_RISE_TIME(i) >= DECAY_TIME(i)
                                    sm_pk_val(i) = NaN;
                                    sm_pk_ind(i) = NaN;
                                    timeindx_decay(i) = timeindx(i);
                                    DECAY_TIME(i) = NaN;
                                    continue
                                end
                            else
                                decay_i = NaN;
                            end

                            decay_ind(i) = decay_i;

                            %single-exp fitting of decay
                            if ~isnan(sm_pk_ind(i)) 
                                decay_vals_forfit = smooth(decay_vals_forfit);
                                [exp_fit,gof] = fit((0:0.2:0.2*num_pts_decay_fit)',decay_vals_forfit,f);

                %                 if timeindx(i) == 17921
                %                 figure
                %                 plot(0:0.2:0.2*num_pts_decay_fit,decay_vals_forfit)
                %                 hold on
                %                 plot(exp_fit)
                %                 disp(gof)
                %                 disp(decay_start_i)
                %                 sm_pk_val(i)
                %                 hold off
                %                 figure
                %                 plot(1:151,norm_event(:,i))
                %                 end
                                %decay_vals_forfit = 1e12*decay_vals_forfit;
                                %[exp_fit,gof] = fit((decay_start_i:decay_start_i+num_pts_decay_fit)',decay_vals_forfit,f);

                                % exclude events with bad decay fitting results
                                % (careful with this criterium)
                                if gof.rsquare < min_decay_rsquare || gof.rmse > max_decay_rmse ...
                                        || exp_fit.b > -0.03000001 
                                    sm_pk_val(i) = NaN;
                                    sm_pk_ind(i) = NaN;
                                    decay_vals_forfit = NaN; 
                                    timeindx_decayfit(i) = timeindx(i);
                                    continue
                                end
                %                         figure
                %                         hold on
                %                         plot((decay_start_i:decay_start_i+num_pts_decay_fit)',decay_vals_forfit)
                %                         plot(exp_fit)
                            end


                            % Charge measurement
                            if ~isnan(sm_pk_ind(i))
                               %the area from baseline to decay end
                                if ~isnan(decay_i)
                                    event_charge = sum(norm_event(numptsBL+1:decay_i_wBL,i))/samplert;
                                else
                                    event_charge = sum(norm_event(numptsBL+1:numptsBL+30,i))/samplert;
                                end

                                %exclude events with charge values less than
                                %the threshold
                                if -event_charge < event_charge_thresh
                                    sm_pk_val(i) = NaN;
                                    sm_pk_ind(i) = NaN;
                                    timeindx_charge(i) = timeindx(i);
                                    continue
                                end
                                
                                EVENT_CHARGE_CURR(i) = -event_charge; %in pC
                            end

                           % refractory period between events should be within
                           % bounds
                           if ~isnan(sm_pk_ind(i))  
                               if i<numel(timeindx)
                                   %events_before_i = sm_pk_ind(1:i-1);
%                                    %i_notnan = find(~isnan(events_before_i),1,'last');
%                                     i_notnan = sm_pk_ind(i-1);
%                                     if (timeindx(i)+event_start_ind{i})...,
%                                         - (timeindx(i_notnan)+sm_pk_ind(i_notnan)+decay_ind(i_notnan)) <= refractory_per

                                   if timeindx(i+1)-timeindx(i) <= refractory_per 
                                    sm_pk_val(i:i+1) = NaN;
                                    sm_pk_ind(i:i+1) = NaN;
                                    timeindx_refractory_per(i) = timeindx(i);
                                    timeindx_refractory_per(i+1) = timeindx(i+1);

                                    continue

                                   end              
                               end
                           end


                            if troubleshoot_events_detect == 1
                                hold on
                                plot(1:151,norm_event(:,i))
                                plot(11,0,'go')
                                plot(rise_start_10pc_i:rise_end_90pc_i,rise_vals_10to90,'g-')
                                plot(decay_start_i:decay_start_i+num_pts_decay_fit,decay_vals_forfit,'r-')
                                plot(exp_fit,'y-')

                                if ~isnan(decay_i)
                                    plot(decay_i_wBL,norm_event(decay_i_wBL,i),'ro')
                                else
                                    plot(numptsBL+30,norm_event(numptsBL+30,i),'ro')
                                end

                                if ~isnan(decay_i)
                                    for g = numptsBL+1:decay_i_wBL
                                        plot([g g],[0 norm_event(g,i)],'y-')
                                    end
                                else
                                    for g = numptsBL+1:numptsBL+30
                                        plot([g g],[0 norm_event(g,i)],'y-')
                                    end
                                end
                                disp(strcat('charge =',num2str(-event_charge)))
                            end

                            %Event amplitude measurements
                            if ~isnan(sm_pk_ind(i))
                                RAW_AMP(i) = pt3_avg(sm_pk_ind(i),i) - mean(BL_vals,'omitnan');
                                if troubleshoot_events_detect == 1
                                    disp(strcat('amp =',num2str(RAW_AMP(i))))
                                    plot(sm_pk_ind(i)-event_start_ind{i}+numptsBL+1,RAW_AMP(i),'bo')
                                    hold off
                                    waitforbuttonpress
                                end
                            end

                        end

                        %remove events whose amplitudes are out of bounds
                        RAW_AMP = -1*RAW_AMP;
                        RAW_AMP(RAW_AMP < amp_cutoff_low) = NaN;
                        RAW_AMP(RAW_AMP > amp_cutoff_high) = NaN;


                        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% WAVEFORM AVG %%%%%%%%%%%%%%%%%%%%%%%%%%%%%

                        disp('Calculating waveform average...')

                        wavgs = NaN(S_E_L,numel(timeindx));
                        for ii = 1:numel(timeindx)
                            if isfinite(RAW_AMP(ii))
                                wave = norm_event(:,ii);
                                wave = wave(1:(S_E_L-20));
                                sm_wave = smooth(wave);

                                time = (0:0.2:0.2*numel(wave(sm_pk_ind(ii)-event_start_ind{ii}+numptsBL+1:numel(wave))))';
                                y = -sm_wave(sm_pk_ind(ii)-event_start_ind{ii}+numptsBL-3:numel(sm_wave)-3);
                                y = y-mean(y(20:numel(y))); 

                                if y(2,1)>y(1,1)
                                    y = y(2:numel(y),1);
                                    time = time(2:numel(time),1);
                                end
                %                 [exp_fit,gof] = fit(time,y,f);
                %                 if troubleshoot_events_wavg == 1
                %                     %                         disp(strcat('exp_fit =',num2str(exp_fit)));
                %                     disp(strcat('gof.rsquare =',num2str(gof.rsquare)));
                %                 end
                %                 cvals = coeffvalues(exp_fit);
                %                 %                 for g = 1:40
                %                 %                     exp_fit_plot(g) = cvals(1)*exp(cvals(2)*y(g));
                %                 %                 end

                                if ii<numel(timeindx)
                                        wave_event_start_ind = numptsBL+1;
                                        wave_event_pk_ind = sm_pk_ind(ii)-(event_start_ind{ii}-numptsBL);

                                        rise_phase_ind = find(sm_wave==max(sm_wave(wave_event_start_ind:wave_event_pk_ind)))...
                                            :find(sm_wave==min(sm_wave(wave_event_start_ind:wave_event_pk_ind)));

                                        if isempty(rise_phase_ind) == 0

                                            tmp_midrise = abs(sm_wave(rise_phase_ind)-sm_pk_val(ii)/2);
                                            [~, mid_rise_ind] = min(tmp_midrise);
                                            mid_rise_ind = mid_rise_ind+rise_phase_ind(1,1)-1;
                                            wavgs((num_zeros_temp_BL*4)-mid_rise_ind:(numel(wave)-mid_rise_ind+((num_zeros_temp_BL*4)-1)),ii) = wave;

                                            if mid_rise_ind >= (num_zeros_temp_BL*4)-1
                                                continue
                                            end

                                            if troubleshoot_events_wavg == 1
                                                plot(time,y)
                                                hold on
                                                %plot(time,exp_fit(y),'g-')
                                                hold off
                                                waitforbuttonpress;
                                            end
                                        else
                                            disp('Warning! Error with midrise calculation!')
                                        end
                                end
                                %         plot(time,y)
                                %         plot(time,exp_fit(time),'g')
                            end

                        end

                        for ii = 1:S_E_L
                            WAVG{1,jj}{1,ci}(ii,ti) = mean(wavgs(ii,:),'omitnan'); %per experiment, per cell, per trace
                        end

                        if figures_on_mini == 1
                            figure('position',[56 200 1400 490])
                            subplot(1,3,3)
                            hold on
                            title('waveform average')
                            for ii = 1:numel(timeindx)
                                if isfinite(mean(wavgs(:,ii),'omitnan'))
                                    plot(wavgs(:,ii),'b')
                                end
                            end
                            plot(WAVG{1,jj}{1,ci}(:,ti),'r','LineWidth',3);
                            shg
                        end

                        %calcuating mean amp and frq for the current trace
                        mean_raw_amp = mean(RAW_AMP,'omitnan'); %in pA
                        total_time = numel(~isnan(aDAT))/samplert; % in seconds
                        counts = sum(~isnan(sm_pk_ind)); 
                        frequency = counts/total_time; % in Hz

                        %%%% All results are saved as the following: 
                        %%%% Per experiment (cell array)-> Per cell (cell array)-> Per
                        %%%% trace (each row in the first column)
                        FRQ{1,jj}{1,ci}(ti,1) = frequency;
                        AMP_ALL{1,jj}{1,ci}(1:numel(RAW_AMP),ti) = RAW_AMP;

                        meanAmp{1,jj}{1,ci}(ti,1) = mean_raw_amp;
                        mini_count{1,jj}{1,ci}(ti,1) = counts;

                        TOTAL_TIME{1,jj}{1,ci}(ti,1) = total_time;
                        RISE{1,jj}{1,ci}(1:numel(RISE_TIME),ti) = RISE_TIME;
                        DECAY{1,jj}{1,ci}(1:numel(DECAY_TIME),ti) = DECAY_TIME;
                        EVENT_CHARGE{1,jj}{1,ci}(1:numel(EVENT_CHARGE_CURR),ti) = EVENT_CHARGE_CURR;
                        wavgs_raw{1,jj}{1,ci}{ti} = wavgs;
                        TIME_INDICES{1,jj}{1,ci}(1:numel(timeindx),ti) = timeindx;
                        aDAT_all{1,jj}{1,ci}(1:numel(aDAT),ti) = aDAT;

                        EVENT_START_INDICES{1,jj}{1,ci}(1:numel(event_start_ind),ti) = event_start_ind;
                        PT3_AVERAGES{1,jj}{1,ci}{ti} = pt3_avg;
                        SMOOTH_PEAK_INDICES{1,jj}{1,ci}(1:numel(sm_pk_ind),ti) = sm_pk_ind;
                        DECAY_INDICES{1,jj}{1,ci}(1:numel(decay_ind),ti) = decay_ind;
                        PT3_DECAY_VALUES{1,jj}{1,ci}{ti} = pt3_decay;

                        %remove zeros from some cell arrays for plotting
                        temp_1 = nonzeros(AMP_ALL{1,jj}{1,ci}(:,ti));
                        AMP_ALL{1,jj}{1,ci}(:,ti) = NaN;
                        AMP_ALL{1,jj}{1,ci}(1:numel(temp_1),ti) = temp_1;

                        temp_2 = nonzeros(RISE{1,jj}{1,ci}(:,ti));
                        RISE{1,jj}{1,ci}(:,ti) = NaN;
                        RISE{1,jj}{1,ci}(1:numel(temp_2),ti) = temp_2;

                        temp_3 = nonzeros(DECAY{1,jj}{1,ci}(:,ti));
                        DECAY{1,jj}{1,ci}(:,ti) = NaN;
                        DECAY{1,jj}{1,ci}(1:numel(temp_3),ti) = temp_3;

                        temp_4 = nonzeros(TIME_INDICES{1,jj}{1,ci}(:,ti));
                        TIME_INDICES{1,jj}{1,ci}(:,ti) = NaN;
                        TIME_INDICES{1,jj}{1,ci}(1:numel(temp_4),ti) = temp_4;

                        temp_5 = nonzeros(aDAT_all{1,jj}{1,ci}(:,ti));
                        aDAT_all{1,jj}{1,ci}(:,ti) = NaN;
                        aDAT_all{1,jj}{1,ci}(1:numel(temp_5),ti) = temp_5;

                        temp_6 = nonzeros(SMOOTH_PEAK_INDICES{1,jj}{1,ci}(:,ti));
                        SMOOTH_PEAK_INDICES{1,jj}{1,ci}(:,ti) = NaN;
                        SMOOTH_PEAK_INDICES{1,jj}{1,ci}(1:numel(temp_6),ti) = temp_6;

                        temp_7 = nonzeros(DECAY_INDICES{1,jj}{1,ci}(:,ti));
                        DECAY_INDICES{1,jj}{1,ci}(:,ti) = NaN;
                        DECAY_INDICES{1,jj}{1,ci}(1:numel(temp_7),ti) = temp_7;


                        %%%%%%%%%%%%%%%%%%%% PLOT RESULTS %%%%%%%%%%%%%%%%%%%%%
                        timeindx_slopeBL = timeindx_slopeBL(~isnan(timeindx_slopeBL));
                        timeindx_rise = timeindx_rise(~isnan(timeindx_rise));
                        timeindx_decay = timeindx_decay(~isnan(timeindx_decay));
                        timeindx_charge = timeindx_charge(~isnan(timeindx_charge));
                        timeindx_BLBAD = timeindx_BLBAD(~isnan(timeindx_BLBAD));
                        timeindx_noiseSTD = timeindx_noiseSTD(~isnan(timeindx_noiseSTD));
                        timeindx_multipk = timeindx_multipk(~isnan(timeindx_multipk));
                        timeindx_otherA = timeindx_otherA(~isnan(timeindx_otherA));
                        timeindx_otherB = timeindx_otherB(~isnan(timeindx_otherB));
                        timeindx_otherC = timeindx_otherC(~isnan(timeindx_otherC));
                        timeindx_otherD = timeindx_otherD(~isnan(timeindx_otherD));
                        timeindx_decay_start = timeindx_decay_start(~isnan(timeindx_decay_start));
                        timeindx_refractory_per = timeindx_refractory_per(~isnan(timeindx_refractory_per));
                        timeindx_decayfit = timeindx_decayfit(~isnan(timeindx_decayfit));
                        timeindx_BLnopts =  timeindx_BLnopts(~isnan(timeindx_BLnopts));
                        timeindx_no_decay = timeindx_no_decay(~isnan(timeindx_no_decay));

                        if figures_on_mini == 1 
                            disp('plotting results:')

                            subplot(1,3,1:2)
                            hold on
                            title(strcat('Cell',num2str(ci),': trace',num2str(ti)),'Interpreter', 'none')
                            plot(aDAT_all{1,jj}{1,ci}(:,ti),'k')

                            scatter(timeindx,repmat( 15 ,1,length(timeindx)),'ro','filled'); % time index of each event
                            scatter(timeindx_slopeBL,repmat( 15.5,1,length(timeindx_slopeBL)),'bx') % baseline slope
                            scatter(timeindx_rise,repmat( 16,1,length(timeindx_rise)),'gx') % rise time
                            scatter(timeindx_decay,repmat( 16.5,1,length(timeindx_decay)),'rx') %decay shorter than rise
                            scatter(timeindx_charge,repmat( 17,1,length(timeindx_charge)),'bo','filled') %charge 
                            scatter(timeindx_BLBAD,repmat( 17.5,1,length(timeindx_BLBAD)),'ko','filled') % bad baseline
                            scatter(timeindx_noiseSTD,repmat( 18,1,length(timeindx_noiseSTD)),'mx') %std of noise
                            scatter(timeindx_multipk,repmat( 18.5,1,length(timeindx_multipk)),'cx') %mulitple peaks
                            scatter(timeindx_otherA,repmat( 19,1,length(timeindx_otherA)),'r*') %peak matches the last value in 3-pts average
                            scatter(timeindx_otherB,repmat( 19.5,1,length(timeindx_otherB)),'y*') %event start after peak
                            scatter(timeindx_otherC,repmat( 20,1,length(timeindx_otherC)),'g*') %Caused error during WAVG
                            scatter(timeindx_otherD,repmat( 20.5,1,length(timeindx_otherD)),'b*') %event starts too late
                            scatter(timeindx_decay_start,repmat( 21,1,length(timeindx_decay_start)),'b+')%decay starts too late
                            scatter(timeindx_refractory_per,repmat( 21.5,1,length(timeindx_refractory_per)),'g+') %time btw events too short
                            scatter(timeindx_decayfit,repmat(22,1,length(timeindx_decayfit)),'r+') %decay is not a good exp fit
                            scatter(timeindx_BLnopts,repmat(21.25,1,length(timeindx_BLnopts)),'k+') %not enought points for baseline
                            scatter(timeindx_no_decay,repmat(21.75,1,length(timeindx_no_decay)),'mo','filled') %decay cannot be found

                            for i = 1:numel(timeindx)
                                %             plot(event(:,i),'k')
                                %             plot(pt3_avg(:,i),'r')
                                %             plot(slope3_avg(:,i),'b')
                                %                     if isnan(AMP_ALL(i,current_ID)) == 0
                                if ~isnan(RAW_AMP(i))
                                    plot(event_start_ind{i}+timeindx(i)-1,...,
                                        mean(aDAT(event_start_ind{i}+timeindx(i)-numptsBL-1:...,
                                        event_start_ind{i}+timeindx(i)-1),'omitnan'),'go') %event start

                                    plot(sm_pk_ind(i)+timeindx(i)-1,pt3_avg(sm_pk_ind(i),i),'bo') % peak position

                                    if ~isnan(decay_ind(i)) 
                                        plot(decay_ind(i)+timeindx(i)+sm_pk_ind(i),...,
                                            pt3_decay(decay_ind(i),i),'ro') % event end
                                    end
                                end
                            end
                            
                            if display_frq == 1
                                frq_str = strcat('frequency = ',num2str(frequency));
                                str_dim = [0.8 0 0.3 0.3];
                                annotation('textbox',str_dim,'String',frq_str,'FitBoxToText','on')
                            end
                                
                                
                        end %%%%plot results

                        s1 = 'Finished: ';
                        disp(strcat(s1,'cell', num2str(ci), ' trace', num2str(ti)))

                        fclose('all');
                    end
            end %trace
        end
        
        %passive property evalution for each cell
        %cell_stats array stores evalution of all passive properties and
        %whether the cell should be included/excluded
        %col.             content
        % 1               mean
        % 2               std
        % 3               coefficient of variation (CV)
        % 4               inclusion index (1=accept, 0=exclude)
        % 5               revised mean
        % 6               revised std
        % 7               revised CV
        
        %col5-7 indicate a second evalution after outlier removal
        %outliers are determined by their median absolute deviation
        %outlier index for each cell stored in cell_stats{jj}.outliers
        
        Rin_curr = nonzeros(Rin{1,jj}{1,ci}(:,1));
        Cm_curr = nonzeros(Cm{1,jj}{1,ci}(:,1));
        Vm_curr = nonzeros(Vm{1,jj}{1,ci}(:,1));
        Rs_curr = nonzeros(Rs{1,jj}{1,ci}(:,1));
        
        [Rin_stats_temp,Rin_outliers_temp] = pp_eval(Rin_curr,pp_cv_cutoff);
        [Cm_stats_temp,Cm_outliers_temp] = pp_eval(Cm_curr,pp_cv_cutoff);
        [Vm_stats_temp,Vm_outliers_temp] = pp_eval(Vm_curr,pp_cv_cutoff);
        [Rs_stats_temp,Rs_outliers_temp] = pp_eval(Rs_curr,pp_cv_cutoff);
        
        
        Rin_stats(ci,1:cell_stats_col) = Rin_stats_temp;
        Cm_stats(ci,1:cell_stats_col) = Cm_stats_temp;
        Vm_stats(ci,1:cell_stats_col) = Vm_stats_temp;
        Rs_stats(ci,1:cell_stats_col) = Rs_stats_temp;
        
        Rin_outliers{1,ci} = Rin_outliers_temp;
        Cm_outliers{1,ci} = Cm_outliers_temp;
        Vm_outliers{1,ci} = Vm_outliers_temp;
        Rs_outliers{1,ci} = Rs_outliers_temp;
        
        %Calculate the stats for event amplitude and frequency across all
        %traces
        
        amp_stats(ci,1) = mean(nonzeros(meanAmp{1,jj}{1,ci}(:,1)),'omitnan');
        amp_stats(ci,2) = std(nonzeros(meanAmp{1,jj}{1,ci}(:,1)),'omitnan');
        
        ave_frq(ci,1) = sum(nonzeros(mini_count{1,jj}{1,ci}(:,1)),'omitnan')/...,
            sum(nonzeros(TOTAL_TIME{1,jj}{1,ci}(:,1)),'omitnan');
        
        
        
        
    end %cell
    
    outliers.Rin = Rin_outliers;
    outliers.Cm = Cm_outliers;
    outliers.Vm = Vm_outliers;
    outliers.Rs = Rs_outliers;
    
    
    cell_stats{1,jj}.Rin_stats = Rin_stats;
    cell_stats{1,jj}.Cm_stats = Cm_stats;
    cell_stats{1,jj}.Vm_stats = Vm_stats;
    cell_stats{1,jj}.Rs_stats = Rs_stats;
    cell_stats{1,jj}.outliers = outliers;
    cell_stats{1,jj}.amp_stats = amp_stats;
    cell_stats{1,jj}.frq = ave_frq;
    
     
end %experiment

%%
%%%%%%%%%%%%%%%%%%%%%%% SAVE RESULTS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
cd(fp_pp)
save(save_pp_file_name,'Cm','Cm_est','Rin','Rs','Rs_est','Vm','cell_stats')

if save_results == 1
    if risetime_cutoff < 2.01 %10-90, 2ms (regular setting for mEPSC)
        cd(strcat(fp_analyzed_data,'/rise_',num2str(1)))
    else
        cd(strcat(fp_analyzed_data,'/rise'))
    end
    
    save(save_mini_file_name,'aDAT_all','AMP_ALL','cell_stats','cell_id','Cm','DECAY','DECAY_INDICES',...
        'EVENT_START_INDICES','FRQ','meanAmp','mini_count','PT3_AVERAGES','PT3_DECAY_VALUES','EVENT_CHARGE',...
        'raw_h5_files','Rin','Rs','RISE','SMOOTH_PEAK_INDICES','TIME_INDICES','TOTAL_TIME','Vm','WAVG','wavgs_raw')
       
end


%% pp eval function
function [eval_results, eval_outliers] = pp_eval(val_temp,pp_cv_cutoff)
    eval_results = NaN(1,7);
    eval_results(1,1) = mean(val_temp,'omitnan');
    eval_results(1,2) = std(val_temp,'omitnan');
    eval_results(1,3) = eval_results(1,2)/eval_results(1,1)*100;

    if eval_results(1,3) > pp_cv_cutoff
        if(sum(isoutlier(val_temp,'median')))>0
            eval_outliers = isoutlier(val_temp,'median');
            eval_rev = val_temp(~eval_outliers,1);
            eval_results(1,4) = sum(eval_outliers);

            eval_results(1,5) = mean(eval_rev,'omitnan');
            eval_results(1,6) = std(eval_rev,'omitnan');
            eval_results(1,7) = eval_results(1,6)/eval_results(1,5)*100;

            if eval_results(1,7) < pp_cv_cutoff
                eval_results(1,4) = 1;
            else
                eval_results(1,4) = 0;
            end
        else
            eval_results(1,4) = 0;
            eval_outliers = [];
        end
    else
        eval_results(1,4) = 1;
        eval_outliers = [];
    end
end